### 综述
#### 并发
两个或更多的任务 同时进行
单核CPU 某一时刻只能执行单个任务 操作系统调度 每秒钟进行多次“任务切换” 并发切换(上下文切换) 有时间开销
  操作系统要保存切换的各种状态 执行进度等 需要时间 切换回来需要复原这些信息
多核CPU 用于服务器和高性能计算机 真正的并发
用于提高性能

#### 进程
linux ./filename 运行起来的可执行程序

#### 线程
每个进程都有一个主线程 唯一的 每个进程只有一个主线程 线程是执行代码的一条道路
产生进程后 主线程跟随这个进程启动 两者相扶相依
运行程序的时候 是进程的主线程调用main函数中的代码
线程来执行代码 主线程执行完main中的return后 便是整个线程运行完毕 主线程结束 进程结束
除了主线程外 可以通过自己写的代码来实现其他线程 可以在同一时刻 执行不同的事 执行不同的代码执行路径
线程不是越多越好 每个线程需要独立的堆栈空间 线程之间切换需要保存中间状态 切换会损耗程序运行的时间

线程用来执行代码
线程理解成代码执行同路 一个线程代表一个新的通路
进程自动包含一个主线程 随进程自动运行 进程中至少有一个线程 通过代码来创建多个其他线程 数量合适
- 优点
>启动速度更快
>系统资源开销更小 执行速度快 共享内存通信方式比任何其他方式快

- 缺点
>使用有难度 小心处理数据的一致性问题

#### 并发实现方法
多进程实现并发
  进程间通信 管道 文件 消息队列 共享内存
            socket 通信技术
多线程实现并发
  每个线程有自己的运行路径 但一个进程中的所有线程共享地址空间(共享内存)
  全局变量 指针 引用 都可以在线程间传递 多心啊程开销远小于多进程
  共享内存问题 数据一致性问题 多线程共同写入数据

#### C++11标准线程库


1. 包含头文件 thread
2. 写初始函数
3. main函数中写代码
  thread obj(fun)
  join() 阻塞，主线程等待子线程执行完，再继续往前走

  detach() 分离 子线程与主线程不汇合 主线程正常结束 无视子线程是否执行完毕
           一旦detach()之后 主线程关联的thread对象会失去与主线程的关联 此时子线程驻留后台运行
           子线程相当于被运行时库接管  当子进程结束后 运行时库负责清理该线程相关的资源
           不可以再用join
           如果是对象 其实是把对象复制到线程里去了(调用拷贝构造) 主线程执行完对象 但子线程依旧保留
  joinable()   判断是否可以使用join 或者是 detach 如果可以 则返回true 否则返回false


#### 线程ID 

ID是个数字 每个线程都对应一个独一无二的线程ID  
std::this_thread::get_id()  来获取

std::chrono::millisecond dura(2000) 持续时间
std::this_thread::sleep_for(dura)  睡眠持续时间

std::ref 不会构建拷贝构造 这样使用detach不安全

#### 多线程执行
1. 多个线程的执行顺序是乱的 跟操作系统内部的运行机制有关
2. 主线程等待所有子线程运行结束 最后主线程结束 
3. thrade对象放到容器里进行管理  ===> thread对象数组 对一次性多线程


#### 数据共享
1. 只读数据: 安全稳定 只需要读出就好
2. 可读可写: 简单的处理 读写不可以同时操作 读线程不能同时读 写线程不能同时写
  即操作共享数据的时候 把共享数据锁住 然后操作数据 解锁
<!-- list 频繁顺序插入删除效率高 vector 随机插入删除效率高 -->
#### 互斥量 mutex
一个互斥量是一个锁
 互斥量是个类对象 多个线程使用lock()尝试加锁 只有一个线程可以锁成功===>lock()函数可以返回
 如果没有锁成功 流程卡在lock()不断尝试锁这把锁 
 
 先lock() 操作共享数据 unlock() 成对使用 
 - std::lock_guard() 不用unlock 

 死锁 至少两把锁
 两个线程AB 两把锁1 2
 1. 线程A执行，把锁1锁住 然后去锁 锁2
 2. 线程B执行，先锁住锁2，然后去锁 锁1
 3. 线程A锁不住锁2 流程走不下去 同时线程B锁不住锁1 流程走不下去 

- 解决方案
    1. 保证多把锁的顺序一样
    2. 使用std::lock()模版函数 用处理多个互斥量    一次可以锁住两个及以上的互斥量 不存在死锁问题
        要么两个互斥量都锁住 要么两个互斥量都没锁住  如果只锁部分锁 另外只要没锁成功 就立即把锁住的锁解锁
        std::lock(mutex1,mutex2,mutex3........)  ====> 然后解锁   
          使用std::lock_guard && std::adopt_lock参数
          adopt_lock是个结构体对象 标记作用: 互斥量已经lock() 不需要在析构函数里再对mutex再加锁
 
- unique_lock
取代lock_guard 
1. 类模版 一般使用lock_guard
2. unique_lock比lock_guard灵活 效率低一些 内存占据多
3. unique_lock支持的参数:
  1. adopt_lock: 标记互斥量已经被lock 互斥量必须提前lock
  2. try_to_lock: 尝试用mutex的lock锁住mutex 如果没有锁住也会立即返回 不会阻塞
  3. defer_lock: 初始化了一个没有加锁的mutex
      unique_lcok成员函数
      1. lock()
      2. unlock()
      3. try_lock() 尝试给互斥量加锁 拿到锁返回true 否则返回false
4. release() 返回管理mutex的对象指针(std::timed_mutex *) 释放所有权 就是mutex和unique没有关系
  若mutex对象处于加锁状态 应该自己解锁 

- 粒度
锁住代码的多少 
锁住代码少 ===> 细粒度 执行效率高 可能漏洞共享数据的保护
锁住代卖多 ===> 粗粒度 执行效率低

mutex 需要 和 unique_lock 绑定 独立绑定

 
std::unique_lock<std::mutex> uni_lock(my_mutex) 所有权的概念
uni_lock 拥有 my_mutex的所有权
但是uni_lock 可以把自己对mutex的所有权转移给其他的unique_lock对象
1. std::unique_lock<std::mutex> uni_lock(std::move(uni_lock))
2. return std::unique_lock<std::mutex>


#### 单例
- 设计模式 程序灵活 维护方便 但是代码易读性差
应对大型项目的时候 把项目开发经验 模块划分经验 总结整理成设计模式

- 单例 整个项目中 有某个或者某些特殊的类 属于该类的对象 只能创建一个对象 

- 多线程中: 需要在我们自己创造的线程(非主线程)中创建CAS单例类的对象，这种线程可能不止一个，可能面临Getinstance()函数互斥

std::call_once(): C++11引入的函数 第二个参数为函数名a() 
call_once() 确保函数a()只能被调用一次 具备互斥量这种能力 效率上比互斥量消耗资源更少。
call_once() 需要与一个标记结合使用 标记为 std::once_flag  其为一个结构
call_once() 通过这个标记来决定对应的函数a()是否执行 调用call_once() 成功后， call_once() 将这个标记设置为已调用状态 再次调用call_once() 时， 只要标记为已调用状态 那么call_once() 就不会再次被调用了。


#### 条件变量

条件变量 std::condition_variable, std::wait(), std::notify_one()
- std::condition_variable: 实际是一个类 和一个条件相关的类 等待调价能达成。
  这个类需要和互斥量相互合作来工作 使用时生成类的对象

wait() 用来等待一个东西
            如果第二个参数 lambda表达式返回true, wait() 直接返回
            如果第二个参数 lambda表达式返回fasle，
               那么wait()将解锁互斥量 并堵塞到本行 等到其他线程调用notify_one()成员函数为止
            如果没有第二个参数 第二个参数lambda表达式返回false一样
            当其他线程用notify_one()将本wait(原本是堵塞\沉睡状态)
            notify_all()唤醒全部的



#### future
- std::async 函数模版 启动一个异步任务 返回 std::future 对象 其为一个类模版
  自动创建一个线程并且开始执行对应的线程入口函数 返回一个 std::future 对象
  这个 std::future 对象里边就含有线程入口函数所返回的结果(线程返回的结果) 我们可以通过调用 std::future 对象的成员函数get()来获取结果 提供了一种访问异步操作结果的机制 ===> 结果不一定马上拿到 在线程执行完毕的时候 就可以拿到结果 
      std::future 对象报错一个值 在将来的某个时刻可以拿到
  如果没有get()拿到值 等待 卡在这里 直到get()拿到值
  wait()等待线程返回 本身不返回任何结果

  可以通过额外向std::async()传递一个参数，该参数类型是std::launch类型(枚举类型)来达到一些特殊的目的。
    1. std::launch::deferred: 表示线程入口函数调用被延迟到std:future的wait()或get()函数调用时才执行
       如果没有wait()或者get()函数调用 则不执行 ===> 线程没有被创建
    2. std::launch::async: 在调用async函数的时候就开始创建线程 为默认的标记

#### packed_task
std::packed_task 是一个类模版 模版参数为各种可调用对象 通过std::packed_task来把各种可调用对象包装起来 方便将来作为线程入口函数

packed_task包装起来的可调用对象还可以直接调用 所以packed_task对象也是一个可调用对象

#### promise
std::promise 类模版 能够在某个线程中赋值 然后我们可以在其他的线程中将这个值取出来
通过promise保存一个值 在将来的某一个时刻我们通过把一个future绑定到这个promise 保存类型为int
